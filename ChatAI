/**
 * ===== REALUNIVERSE AI MASTER LIBRARY =====
 * Version: 1.1.0 (Added: Thinking Mode Support)
 */
/* ------------------ CONFIGURATION ------------------ */
const API_URL = 'https://api.openai.com/v1/chat/completions';
const RESPONSES_API_URL = 'https://api.openai.com/v1/responses';
const IMAGE_API_URL = 'https://api.openai.com/v1/images/generations';

const MODEL_CONFIG = {
  action_standard: { model: 'gpt-4.1', max_tokens: 10000 },
  action_turbo: { model: 'gpt-4.1', max_tokens: 20000 },
  array: { model: 'gpt-4.1', max_tokens: 2000 },
  image: { model: 'dall-e-3', size: '1024x1024', quality: 'hd', n: 1 }
};

const TEMPERATURE_PRESETS = [0, 0.2, 0.4, 0.7];

const TURBO_CHUNK_CHAR_LIMIT_ACTION = 20000;
const MAX_TOTAL_ROWS_TURBO = 10000;
const PARALLEL_BATCH_SIZE = 3;
const PARALLEL_DELAY_MS = 1000;

const MAX_ROWS_PER_BATCH_ARRAY = 25;
const MAX_TOTAL_ROWS_ARRAY = 10000;

const SIDEBAR_WIDTH = 600;
const SIDEBAR_HEIGHT = 900;
const CHAT_SHEET_NAME = 'ChatHistory';
const DEBUG_LOG_SHEET_NAME = 'DebugLog';

/* ------------------ THINKING MODE CONFIGURATION ------------------ */
const THINKING_SYSTEM_MESSAGE = `You are a professional data analyst with deep analytical capabilities.

Your task is to explain your thinking process before providing the final analysis. Structure your thinking as follows:

DATA UNDERSTANDING
- Analyze the data structure and composition
- Identify data types, patterns, and relationships
- Note any data quality issues or limitations

OBJECTIVE ANALYSIS
- Clarify what the user question is asking
- Identify the key metrics or insights needed
- Determine the appropriate analysis approach

STRATEGY PLANNING
- Break down the analysis into clear steps
- Specify methods and techniques to be used
- Outline the logical flow of analysis

POTENTIAL CHALLENGES
- Identify data limitations or constraints
- Anticipate potential issues
- Plan mitigation strategies

EXPECTED OUTCOME
- Describe the anticipated insights
- Specify the presentation format
- Set expectations for the results

Provide detailed, professional thinking in Thai language. Be thorough but concise.`;

const TURBO_THINKING_SYSTEM_MESSAGE = `You are a strategic data analyst planning a large-scale data analysis.

Your task is to create a high-level strategic plan for analyzing large datasets. Focus on:

DATASET OVERVIEW
- Overall data structure and volume
- Key variables and their relationships
- Data distribution patterns

ANALYSIS STRATEGY
- How to efficiently process large volumes
- Which insights to prioritize
- How to combine chunk-level insights

QUALITY ASSURANCE
- How to maintain consistency across chunks
- How to validate results
- How to handle edge cases

SYNTHESIS APPROACH
- How to aggregate chunk insights
- How to ensure coherent final output
- What patterns to look for across all data

Provide strategic thinking in Thai language. Focus on the big picture.`;

/**
 * Generate thinking prompt for standard mode
 */
function generateThinkingPrompt(dataInfo, userPrompt) {
  return `‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£: "${userPrompt}"

${dataInfo}

‡πÇ‡∏õ‡∏£‡∏î‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Å‡∏£‡∏∞‡∏ö‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏¥‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ï‡∏≤‡∏°‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î`;
}

/**
 * Generate strategic thinking prompt for turbo mode
 */
function generateTurboThinkingPrompt(dataOverview, userPrompt) {
  return `‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£: "${userPrompt}"

‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:
${dataOverview}

‡πÇ‡∏õ‡∏£‡∏î‡∏ß‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏ô‡∏≤‡∏î‡πÉ‡∏´‡∏ç‡πà‡∏ô‡∏µ‡πâ`;
}

/**
 * Call Thinking API for standard mode
 */
function callThinkingAPI(dataInfo, userPrompt) {
  try {
    const thinkingPrompt = generateThinkingPrompt(dataInfo, userPrompt);
    
    const payload = {
      model: MODEL_CONFIG.action_standard.model,
      messages: [
        { role: 'system', content: THINKING_SYSTEM_MESSAGE },
        { role: 'user', content: thinkingPrompt }
      ],
      temperature: 0.3,
      max_tokens: 4000
    };

    return makeRealUniverseApiCallWithRetry(payload);
    
  } catch (e) {
    Logger.log('Error in callThinkingAPI: ' + e.message);
    throw new Error('Thinking process failed: ' + e.message);
  }
}

/**
 * Call Thinking API for turbo mode
 */
function callTurboThinkingAPI(dataOverview, userPrompt) {
  try {
    const thinkingPrompt = generateTurboThinkingPrompt(dataOverview, userPrompt);
    
    const payload = {
      model: MODEL_CONFIG.action_turbo.model,
      messages: [
        { role: 'system', content: TURBO_THINKING_SYSTEM_MESSAGE },
        { role: 'user', content: thinkingPrompt }
      ],
      temperature: 0.3,
      max_tokens: 3000
    };

    return makeRealUniverseApiCallWithRetry(payload);
    
  } catch (e) {
    Logger.log('Error in callTurboThinkingAPI: ' + e.message);
    throw new Error('Strategic thinking failed: ' + e.message);
  }
}

/**
 * Build enhanced context with thinking process
 */
function buildContextWithThinking(thinkingProcess, dataInfo, userPrompt) {
  return `[THINKING PROCESS]
${thinkingProcess}

[DATA]
${dataInfo}

[USER REQUEST]
${userPrompt}

‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ï‡∏≤‡∏°‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡∏≤‡∏á‡πÑ‡∏ß‡πâ ‡πÅ‡∏•‡∏∞‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô`;
}

/**
 * Build turbo context with strategic thinking
 */
function buildTurboContextWithThinking(strategicThinking, chunkData, chunkNumber, totalChunks, userPrompt) {
  return `[STRATEGIC PLAN]
${strategicThinking}

[CURRENT CHUNK]
Chunk ${chunkNumber}/${totalChunks}

${chunkData}

[TASK]
‡∏ï‡∏≤‡∏°‡πÅ‡∏ú‡∏ô‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏Ç‡πâ‡∏≤‡∏á‡∏ï‡πâ‡∏ô ‡πÉ‡∏´‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡∏∏‡∏õ‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö: "${userPrompt}"`;
}

/* ------------------ DYNAMIC PRESET FUNCTIONS ------------------ */

function getDynamicPresets() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Preset');

  if (!sheet) {
    throw new Error('‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö Sheet "Preset" ‡πÇ‡∏õ‡∏£‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á Sheet ‡∏ä‡∏∑‡πà‡∏≠ "Preset" ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
  }

  try {
    const presets = {
      action: {},
      array: {},
      image: {}
    };

    const actionRange = sheet.getRange('A2:B21');
    const actionValues = actionRange.getValues();

    actionValues.forEach((row, index) => {
      const [name, systemMessage] = row;
      if (name && String(name).trim() && systemMessage && String(systemMessage).trim()) {
        const key = `action_preset_${index + 2}`;
        presets.action[key] = {
          SYSTEM_MESSAGE: `Preset!B${index + 2}`,
          DISPLAY_NAME: String(name).trim(),
          ROW_NUMBER: index + 2
        };
      }
    });

    const arrayRange = sheet.getRange('D2:E21');
    const arrayValues = arrayRange.getValues();

    arrayValues.forEach((row, index) => {
      const [name, systemMessage] = row;
      if (name && String(name).trim() && systemMessage && String(systemMessage).trim()) {
        const key = `array_preset_${index + 2}`;
        presets.array[key] = {
          SYSTEM_MESSAGE: `Preset!E${index + 2}`,
          DISPLAY_NAME: String(name).trim(),
          ROW_NUMBER: index + 2
        };
      }
    });

    const imageRange = sheet.getRange('G2:H21');
    const imageValues = imageRange.getValues();

    imageValues.forEach((row, index) => {
      const [name, promptTemplate] = row;
      if (name && String(name).trim() && promptTemplate && String(promptTemplate).trim()) {
        const key = `image_preset_${index + 2}`;
        presets.image[key] = {
          SYSTEM_MESSAGE: `Preset!H${index + 2}`,
          DISPLAY_NAME: String(name).trim(),
          ROW_NUMBER: index + 2
        };
      }
    });

    if (Object.keys(presets.action).length === 0 && Object.keys(presets.array).length === 0) {
      throw new Error('‚ùå Sheet "Preset" ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤\n\n‡πÇ‡∏õ‡∏£‡∏î‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Preset:\n- Action Presets: ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå A-B (‡∏ä‡∏∑‡πà‡∏≠-‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á)\n- Array Presets: ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå D-E (‡∏ä‡∏∑‡πà‡∏≠-‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á)');
    }

    Logger.log('Dynamic presets loaded successfully:');
    Logger.log('Action presets: ' + Object.keys(presets.action).length);
    Logger.log('Array presets: ' + Object.keys(presets.array).length);

    return presets;

  } catch (e) {
    if (e.message.includes('‚ùå')) throw e;
    throw new Error('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô Sheet "Preset":\n' + e.message);
  }
}

function getPresetDescriptionByKey(presetKey) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Preset');
    if (!sheet) return '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢';

    if (presetKey.includes('action_preset_')) {
      const rowNum = presetKey.split('_')[2];
      const descValue = sheet.getRange(`C${rowNum}`).getValue();
      if (descValue && String(descValue).trim()) return String(descValue).trim();
    } else if (presetKey.includes('array_preset_')) {
      const rowNum = presetKey.split('_')[2];
      const descValue = sheet.getRange(`F${rowNum}`).getValue();
      if (descValue && String(descValue).trim()) return String(descValue).trim();
    } else if (presetKey.includes('image_preset_')) {
      const rowNum = presetKey.split('_')[2];
      const descValue = sheet.getRange(`I${rowNum}`).getValue();
      if (descValue && String(descValue).trim()) return String(descValue).trim();
    }

    return '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢';
  } catch (e) {
    return '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÑ‡∏î‡πâ';
  }
}
/* ------------------ MAIN LIBRARY FUNCTIONS ------------------ */
function onOpen() {
  initializeRealUniverse();
}

function initializeRealUniverse() {
  const ui = SpreadsheetApp.getUi();

  try {
    ui.createMenu('‚óâ‚Éù‚óâ RealUniverse')
      .addItem('‚ÜóÔ∏è Launch AI', 'launchRealUniverseAI')
      .addSeparator()
      .addItem('‚öôÔ∏è Set API Key', 'setupRealUniverseApiKey')
      .addItem('üóëÔ∏è Clear Chat History', 'clearRealUniverseHistory')
      .addToUi();

  } catch (e) {
    Logger.log('Error initializing RealUniverse: ' + e.message);
    ui.alert('Installation Error',
      'There was an error setting up RealUniverse AI. Please try refreshing the page and running the installation again.',
      ui.ButtonSet.OK);
  }
}

function launchRealUniverseAI() {
  showRealUniverseChat();
}

function showRealUniverseChat() {
  try {
    const properties = PropertiesService.getScriptProperties();
    const displayMode = 'modeless';

    if (displayMode === 'sidebar') {
      showRealUniverseSidebar();
    } else {
      showRealUniverseModeless();
    }

  } catch (e) {
    Logger.log('Error showing chat: ' + e.message);
    SpreadsheetApp.getUi().alert('Error', 'Could not launch AI interface: ' + e.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

function showRealUniverseSidebar() {
  try {
    const properties = PropertiesService.getScriptProperties();
    properties.setProperty('REALUNIVERSE_DISPLAY_MODE', 'sidebar');

    const htmlContent = getRealUniverseHtmlContent();
    const html = HtmlService.createHtmlOutput(htmlContent).setWidth(320);

    SpreadsheetApp.getUi().showSidebar(html.setTitle(' '));
  } catch (e) {
    Logger.log('Error showing sidebar: ' + e.message);
    SpreadsheetApp.getUi().alert('Error', 'Could not launch sidebar: ' + e.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

function showRealUniverseModeless() {
  try {
    const properties = PropertiesService.getScriptProperties();
    properties.setProperty('REALUNIVERSE_DISPLAY_MODE', 'modeless');

    const htmlContent = getRealUniverseHtmlContent();
    const html = HtmlService.createHtmlOutput(htmlContent);
    html.setWidth(SIDEBAR_WIDTH).setHeight(SIDEBAR_HEIGHT);

    SpreadsheetApp.getUi().showModelessDialog(html, ' ');
  } catch (e) {
    Logger.log('Error showing modeless: ' + e.message);
    SpreadsheetApp.getUi().alert('Error', 'Could not launch modeless dialog: ' + e.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

function toggleDisplayMode() {
  try {
    const properties = PropertiesService.getScriptProperties();
    const currentMode = properties.getProperty('REALUNIVERSE_DISPLAY_MODE') || 'modeless';

    const newMode = currentMode === 'modeless' ? 'sidebar' : 'modeless';
    properties.setProperty('REALUNIVERSE_DISPLAY_MODE', newMode);

    const ui = SpreadsheetApp.getUi();
    const emptyHtml = HtmlService.createHtmlOutput('<script>google.script.host.close();</script>');

    if (currentMode === 'modeless') {
      emptyHtml.setWidth(1).setHeight(1);
      ui.showModelessDialog(emptyHtml, 'Closing...');
      Utilities.sleep(150);
    } else {
      emptyHtml.setWidth(1);
      ui.showSidebar(emptyHtml.setTitle('Closing...'));
      Utilities.sleep(150);
    }

    const htmlContent = getRealUniverseHtmlContent();
    const html = HtmlService.createHtmlOutput(htmlContent);

    if (newMode === 'sidebar') {
      html.setWidth(320);
      ui.showSidebar(html.setTitle(' '));
    } else {
      html.setWidth(SIDEBAR_WIDTH).setHeight(SIDEBAR_HEIGHT);
      ui.showModelessDialog(html, ' ');
    }

  } catch (e) {
    Logger.log('Error toggling display mode: ' + e.message);
    SpreadsheetApp.getUi().alert('Error', 'Could not switch display mode: ' + e.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

function getCurrentDisplayMode() {
  try {
    const properties = PropertiesService.getScriptProperties();
    return properties.getProperty('REALUNIVERSE_DISPLAY_MODE') || 'modeless';
  } catch (e) {
    Logger.log('Error getting display mode: ' + e.message);
    return 'modeless';
  }
}

function setupRealUniverseApiKey() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt(
    'Set OpenAI API Key',
    'Please enter your OpenAI API key (starts with "sk-"):\n\nYou can get one from: https://platform.openai.com/api-keys',
    ui.ButtonSet.OK_CANCEL
  );

  if (response.getSelectedButton() == ui.Button.OK) {
    const apiKey = response.getResponseText().trim();
    if (apiKey.startsWith('sk-')) {
      PropertiesService.getScriptProperties().setProperty('REALUNIVERSE_API_KEY', apiKey);
      ui.alert('Success!', 'Your API Key has been saved securely. You can now use RealUniverse AI!', ui.ButtonSet.OK);
    } else {
      ui.alert('Error', 'Invalid API Key format. It must start with "sk-".', ui.ButtonSet.OK);
    }
  }
}

/* ------------------ CORE AI PROCESSING FUNCTIONS ------------------ */

function processRealUniverseAI(prompt, preset, temperature, mode, turboMode, thinkingMode) {
  try {
    if (mode === 'action') {
      if (turboMode) {
        return processRealUniverseTurbo(prompt, preset, temperature, thinkingMode);
      } else {
        return processRealUniverseStandard(prompt, preset, temperature, thinkingMode);
      }
    } else if (mode === 'array') {
      return processRealUniverseArray(prompt, preset, temperature);
    } else if (mode === 'image') {
      return processRealUniverseImage(prompt, preset, temperature);
    }

    throw new Error('Invalid mode specified');
  } catch (e) {
    Logger.log('Error in processRealUniverseAI: ' + e.message);
    return 'ERROR: ' + e.message;
  }
}

function isNumeric(value) {
  if (value == null || value === '') return false;
  const cleanedValue = String(value).replace(/,/g, '');
  return !isNaN(cleanedValue) && !isNaN(parseFloat(cleanedValue));
}

function processRealUniverseStandard(prompt, preset, temperature, thinkingMode) {
  const systemMessage = getRealUniverseSystemMessage(getDynamicPresetSystemMessage(preset, 'action'), 'action');
  const config = MODEL_CONFIG.action_standard;

  let allDataArray = [];
  const rangeList = SpreadsheetApp.getActiveRangeList();
  if (!rangeList) {
    const errorMessage = 'No cells selected';
    saveRealUniverseHistory(prompt, errorMessage);
    return errorMessage;
  }

  const ranges = rangeList.getRanges();

  ranges.forEach(range => {
    let visibleRowsAndNumbers = getVisibleCellsForActionWithRowNumbers(range);
    visibleRowsAndNumbers.forEach(item => {
      const cleanedRow = item.data.map(val => cleanCellData(val));
      if (cleanedRow.some(val => val !== '')) {
        allDataArray.push({
          rowNumber: item.rowNumber,
          data: cleanedRow
        });
      }
    });
  });

  const wordCount = allDataArray
    .map(row => row.data.join(' '))
    .join(' ')
    .split(/\s+/)
    .filter(word => word.length > 0)
    .length;

  if (wordCount > 20000) {
    const errorMessage = '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏°‡∏µ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ üí° Deep Analysis';
    saveRealUniverseHistory(prompt, errorMessage);
    return errorMessage;
  }

  const firstRange = ranges[0];
  const sheetName = firstRange.getSheet().getName();
  const rangeNotation = ranges.map(r => r.getA1Notation()).join(', ');
  const totalCols = firstRange.getNumColumns();
  const totalRowsVisible = allDataArray.length;
  const rangeInfo = `Selected Range: ${sheetName}!${rangeNotation} (${totalCols} columns, ${totalRowsVisible} visible rows)`;

  const dataAnalysis = analyzeDataStructure(allDataArray);

  let enhancedPrompt = prompt;
  let enhancedSystemMessage = systemMessage;

  if (dataAnalysis.dataType === 'content_only') {
    enhancedSystemMessage += '\n\n‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤/‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°:\n' +
      '- ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ï‡∏≤‡∏° Preset ‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î\n' +
      '- ‡∏´‡πâ‡∏≤‡∏°‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡πÄ‡∏•‡∏Ç Row ‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡∏°‡∏≤‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÄ‡∏î‡πá‡∏î‡∏Ç‡∏≤‡∏î\n';

    enhancedPrompt = formatContentOnlyData(allDataArray, prompt, rangeInfo);

  } else if (dataAnalysis.dataType === 'mixed_data') {
    const calculations = performCalculations(allDataArray, dataAnalysis);

    enhancedSystemMessage += '\n\n‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÅ‡∏ö‡∏ö‡∏ú‡∏™‡∏° (‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° + ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç):\n' +
      '- ‡πÉ‡∏ä‡πâ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ó‡∏µ‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏à‡∏≤‡∏Å pre-processing\n' +
      '- ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ï‡∏≤‡∏° Preset ‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î\n' +
      '- ‡∏´‡πâ‡∏≤‡∏°‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡πÄ‡∏•‡∏Ç Row ‡∏ó‡∏µ‡πà‡∏ô‡∏≥‡∏°‡∏≤‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡πÄ‡∏î‡πá‡∏î‡∏Ç‡∏≤‡∏î\n';

    enhancedPrompt = formatMixedData(allDataArray, calculations, prompt, rangeInfo);
  }

if (thinkingMode) {
    const dataInfo = rangeInfo + '\n\n' + enhancedPrompt;
    
    Logger.log('=== DEBUG THINKING MODE ===');
    Logger.log('Calling Thinking API...');
    
    const thinkingResult = callThinkingAPI(dataInfo, prompt);
    
    Logger.log('Thinking Result Length: ' + thinkingResult.length);
    Logger.log('Thinking Result: ' + thinkingResult.substring(0, 200) + '...');
    
    const contextWithThinking = buildContextWithThinking(thinkingResult, enhancedPrompt, prompt);
    
    const payload = {
      model: config.model,
      messages: [
        { role: 'system', content: enhancedSystemMessage },
        { role: 'user', content: contextWithThinking }
      ],
      temperature: temperature,
      max_tokens: config.max_tokens
    };

    const result = makeRealUniverseApiCallWithRetry(payload);
    
    Logger.log('Final Answer Length: ' + result.length);
    Logger.log('Final Answer: ' + result.substring(0, 200) + '...');
    
    saveRealUniverseHistory(prompt + ' (Smart + Thinking)', result);
    
    const jsonResponse = JSON.stringify({
      thinking: thinkingResult,
      answer: result
    });
    
    Logger.log('JSON Response Length: ' + jsonResponse.length);
    Logger.log('=== END DEBUG ===');
    
    return jsonResponse;
    
  } else {
    const payload = {
      model: config.model,
      messages: [
        { role: 'system', content: enhancedSystemMessage },
        { role: 'user', content: enhancedPrompt }
      ],
      temperature: temperature,
      max_tokens: config.max_tokens
    };

    const result = makeRealUniverseApiCallWithRetry(payload);
    saveRealUniverseHistory(prompt + ' (Smart)', result);
    return result;
  }

function getDynamicPresetSystemMessage(presetKey, mode) {
  try {
    const presets = getDynamicPresets();
    const modePresets = presets[mode] || {};

    if (modePresets[presetKey]) {
      return modePresets[presetKey].SYSTEM_MESSAGE;
    }

    const firstKey = Object.keys(modePresets)[0];
    if (firstKey) return modePresets[firstKey].SYSTEM_MESSAGE;

    throw new Error('No presets available for mode: ' + mode);
  } catch (e) {
    Logger.log('Error getting dynamic preset: ' + e.message);
    throw e;
  }
}

function analyzeDataStructure(dataArray) {
  if (!dataArray || dataArray.length === 0) {
    return { dataType: 'empty', columns: [] };
  }

  const sampleRow = dataArray[0].data;
  const columnAnalysis = [];

  for (let colIndex = 0; colIndex < sampleRow.length; colIndex++) {
    const columnValues = dataArray.map(row => row.data[colIndex]).filter(val => val !== '');
    if (columnValues.length === 0) continue;

    const numericValues = columnValues.filter(val => isNumeric(val));
    const uniqueValues = [...new Set(columnValues)];

    const numericRatio = numericValues.length / columnValues.length;
    const hasDuplicates = uniqueValues.length < columnValues.length;
    const duplicateRatio = hasDuplicates ? (columnValues.length - uniqueValues.length) / columnValues.length : 0;

    const analysis = {
      index: colIndex,
      type: 'unknown',
      hasNumbers: numericValues.length > 0,
      isNumeric: numericRatio > 0.8,
      isCategory: hasDuplicates && uniqueValues.length >= 2 && uniqueValues.length <= 20 && duplicateRatio > 0.2,
      isText: numericRatio < 0.3,
      uniqueCount: uniqueValues.length,
      totalCount: columnValues.length
    };

    if (analysis.isNumeric)      analysis.type = 'number';
    else if (analysis.isCategory) analysis.type = 'category';
    else if (analysis.isText)     analysis.type = 'text';
    else                          analysis.type = 'mixed';

    columnAnalysis.push(analysis);
  }

  const hasNumbers = columnAnalysis.some(col => col.type === 'number');
  const hasCategories = columnAnalysis.some(col => col.type === 'category');
  const hasText = columnAnalysis.some(col => col.type === 'text');

  let dataType = 'content_only';
  if (hasNumbers && (hasCategories || hasText)) dataType = 'mixed_data';

  return {
    dataType: dataType,
    columns: columnAnalysis,
    totalRows: dataArray.length,
    numberColumns: columnAnalysis.filter(col => col.type === 'number'),
    categoryColumns: columnAnalysis.filter(col => col.type === 'category'),
    textColumns: columnAnalysis.filter(col => col.type === 'text'),
    mixedColumns: columnAnalysis.filter(col => col.type === 'mixed')
  };
}

function formatContentOnlyData(dataArray, userPrompt, rangeInfo) {
  const contentText = dataArray.map(row =>
    `Row ${row.rowNumber}: ${row.data.filter(val => val !== '').join(' | ')}`
  ).join('\n');

  return `${userPrompt}\n\n${rangeInfo}\n\n‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå:\n${contentText}`;
}

function performCalculations(dataArray, analysis) {
  const calculations = { summary: {}, groups: {}, totals: {} };

  try {
    analysis.numberColumns.forEach(numCol => {
      const values = dataArray
        .map(row => row.data[numCol.index])
        .filter(val => isNumeric(val))
        .map(val => parseFloat(String(val).replace(/,/g, '')));
      calculations.totals[`column_${numCol.index}`] = {
        sum: values.reduce((sum, val) => sum + val, 0),
        count: values.length
      };
    });

    analysis.categoryColumns.forEach(catCol => {
      analysis.numberColumns.forEach(numCol => {
        const groupKey = `${catCol.index}_to_${numCol.index}`;
        const groups = {};

        dataArray.forEach(row => {
          const category = row.data[catCol.index];
          const value = row.data[numCol.index];
          if (category && isNumeric(value)) {
            if (!groups[category]) groups[category] = [];
            groups[category].push(parseFloat(String(value).replace(/,/g, '')));
          }
        });

        const groupSummaries = {};
        Object.keys(groups).forEach(category => {
          const values = groups[category];
          groupSummaries[category] = {
            sum: values.reduce((sum, val) => sum + val, 0),
            count: values.length
          };
        });

        calculations.groups[groupKey] = groupSummaries;
      });
    });

  } catch (e) {
    Logger.log('Error in calculations: ' + e.message);
    calculations.error = 'Could not complete all calculations';
  }

  return calculations;
}

function formatMixedData(dataArray, calculations, userPrompt, rangeInfo) {
  const rawDataText = dataArray.map(row => `Row ${row.rowNumber}: ${row.data.join(', ')}`).join('\n');

  let calculationsText = '\n‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì (Pre-calculated Results):\n';

  if (Object.keys(calculations.totals).length > 0) {
    calculationsText += '\n‡∏ú‡∏•‡∏£‡∏ß‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå:\n';
    Object.entries(calculations.totals).forEach(([key, data]) => {
      calculationsText += `- ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå ${key}: ‡∏£‡∏ß‡∏° ${data.sum.toLocaleString()} ‡∏à‡∏≤‡∏Å ${data.count} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n`;
    });
  }

  if (Object.keys(calculations.groups).length > 0) {
    calculationsText += '\n‡∏ú‡∏•‡∏£‡∏ß‡∏°‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°:\n';
    Object.entries(calculations.groups).forEach(([groupKey, groupData]) => {
      calculationsText += `\n‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏° ${groupKey}:\n`;
      Object.entries(groupData).forEach(([category, data]) => {
        calculationsText += `- ${category}: ‡∏£‡∏ß‡∏° ${data.sum.toLocaleString()} ‡∏à‡∏≤‡∏Å ${data.count} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n`;
      });
    });
  }

  return `${userPrompt}\n\n${rangeInfo}\n\n‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡∏¥‡∏ö:\n${rawDataText}${calculationsText}\n\n‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: ‡πÉ‡∏ä‡πâ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡πâ‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡∏ï‡∏≠‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥`;
}

function processRealUniverseTurbo(userPrompt, presetName, temperature, thinkingMode) {
  const reduceSystemMessage = getRealUniverseSystemMessage(getDynamicPresetSystemMessage(presetName, 'action'), 'action');
  const config = MODEL_CONFIG.action_turbo;

  const rangeList = SpreadsheetApp.getActiveRangeList();
  if (!rangeList) throw new Error('No cells selected.');

  const ranges = rangeList.getRanges();
  const firstRange = ranges[0];
  const sheetName = firstRange.getSheet().getName();
  const rangeNotation = ranges.map(r => r.getA1Notation()).join(', ');

  let allDataLines = [];

  ranges.forEach(range => {
    const visibleValuesAndRows = getVisibleCellsForActionWithRowNumbers(range);
    visibleValuesAndRows.forEach(item => {
      const processedRow = item.data.map(val => cleanCellData(val)).filter(val => val !== '').join(', ');
      if (processedRow) allDataLines.push(`Row ${item.rowNumber}: ${processedRow}`);
    });
  });

  const totalRowsVisible = allDataLines.length;
  const totalCols = firstRange.getNumColumns();
  const rangeInfo = `Selected Range: ${sheetName}!${rangeNotation} (${totalCols} columns, ${totalRowsVisible} visible rows)`;

  if (totalRowsVisible > MAX_TOTAL_ROWS_TURBO)
    throw new Error('‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà‡∏°‡∏≠‡∏á‡πÄ‡∏´‡πá‡∏ô‡πÑ‡∏î‡πâ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î: ' + totalRowsVisible + ' > ' + MAX_TOTAL_ROWS_TURBO);

  let strategicThinking = null;

  if (thinkingMode) {
    const dataOverview = `${rangeInfo}\n\nTotal data lines: ${totalRowsVisible}\n\nSample data (first 10 rows):\n${allDataLines.slice(0, 10).join('\n')}`;
    strategicThinking = callTurboThinkingAPI(dataOverview, userPrompt);
  }

  const mapSystemMessage = thinkingMode
    ? 'data analysis assistant specialized in processing large datasets.\n' +
      'STRATEGIC PLAN:\n' + strategicThinking + '\n\n' +
      'DATA CONTEXT: ' + rangeInfo + '\n' +
      'USER REQUEST: "' + userPrompt + '"\n' +
      'Follow the strategic plan above. Extract and summarize information from data chunks.\n' +
      'Data format: Row <number>: value1, value2, value3\n' +
      'Return JSON format: { "row": "<start-end>", "chunk": <number>, "summary": "<focused_summary>" }\n' +
      'Requirements:\n- Summary in Thai\n- 700-800 words\n- Focus only on relevant information'
    : 'data analysis assistant specializing in processing large datasets in chunks.\n' +
      'DATA CONTEXT: ' + rangeInfo + '\n' +
      'USER REQUEST: "' + userPrompt + '"\n' +
      'Extract and summarize information from data chunks relevant to the user request.\n' +
      'Data format: Row <number>: value1, value2, value3\n' +
      'Return JSON format: { "row": "<start-end>", "chunk": <number>, "summary": "<focused_summary>" }\n' +
      'Requirements:\n- Summary in Thai\n- 700-800 words\n- Focus only on relevant information';

  const dataChunks = chunkDataByCharLimit(allDataLines, TURBO_CHUNK_CHAR_LIMIT_ACTION);
  const summaries = [];

  for (let i = 0; i < dataChunks.length; i++) {
    const chunk = dataChunks[i];
    if (!chunk || chunk.trim() === '') continue;

    const chunkRowCount = chunk.split('\n').length;

    const chunkContent = thinkingMode
      ? buildTurboContextWithThinking(strategicThinking, chunk, i + 1, dataChunks.length, userPrompt)
      : '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡πà‡∏ß‡∏ô‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå: "' + userPrompt + '"\nChunk ' + (i + 1) + '/' + dataChunks.length + ' (' + chunkRowCount + ' rows):\n' + chunk;

    const payload = {
      model: config.model,
      messages: [
        { role: 'system', content: mapSystemMessage },
        { role: 'user', content: chunkContent }
      ],
      temperature: temperature,
      max_tokens: 4096,
      response_format: { "type": "json_object" }
    };

    try {
      const result = makeRealUniverseApiCallWithRetry(payload);
      const summary = JSON.parse(result);
      summaries.push(summary);
    } catch (e) {
      summaries.push({ row: (i + 1).toString(), chunk: i + 1, summary: 'Failed to process chunk' });
    }
  }

  const combinedSummaries = JSON.stringify(summaries, null, 2);
  
  const finalContent = thinkingMode
    ? 'STRATEGIC PLAN:\n' + strategicThinking + '\n\nBased on these summaries:\n\n' + combinedSummaries + '\n\nAnswer the user request: "' + userPrompt + '"'
    : 'Based on these summaries:\n\n' + combinedSummaries + '\n\nAnswer the user request: "' + userPrompt + '"';

  const finalPayload = {
    model: config.model,
    messages: [
      { role: 'system', content: reduceSystemMessage + '\n\nADDITIONAL CONTEXT: You are analyzing summaries from multiple data chunks. Combine insights from all chunks to create a comprehensive big picture analysis.\n\nRESPONSE REQUIREMENTS:\n- Provide detailed analysis with specific examples and numbers\n- Answer must be between 1000-1500 words\n- Include comprehensive insights from all data chunks\n\n- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ "ü§ì ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ [‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á]" ‡πÅ‡∏•‡∏∞‡∏à‡∏ö‡∏î‡πâ‡∏ß‡∏¢ "‡∏´‡∏ß‡∏±‡∏á‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏öüòä"' },
      { role: 'user', content: finalContent }
    ],
    temperature: temperature,
    max_tokens: config.max_tokens
  };

  const result = makeRealUniverseApiCallWithRetry(finalPayload);
  saveRealUniverseHistory(userPrompt + ' (Turbo)', result);

  if (thinkingMode) {
    return JSON.stringify({
      thinking: strategicThinking,
      answer: result
    });
  } else {
    return result;
  }
}

function getSheetRowMetadata(sheet) {
  const spreadsheetId = SpreadsheetApp.getActiveSpreadsheet().getId();
  const sheetName = sheet.getName();
  try {
    const response = Sheets.Spreadsheets.get(spreadsheetId, {
      ranges: [sheetName],
      fields: 'sheets.properties,sheets.data.rowMetadata'
    });
    const sheetData = response.sheets && response.sheets.length > 0 ? response.sheets[0] : null;
    return sheetData && sheetData.data && sheetData.data.length > 0 ? sheetData.data[0].rowMetadata : [];
  } catch (e) {
    Logger.log('Error fetching sheet row metadata from Sheets API: ' + e.message);
    return [];
  }
}

function hasHiddenRowsInRange(range) {
  const sheet = range.getSheet();
  const rowMetadata = getSheetRowMetadata(sheet);

  if (!rowMetadata || rowMetadata.length === 0) {
    const filter = sheet.getFilter();
    if (!filter) return false;
    const startRow = range.getRow();
    const numRows = range.getNumRows();
    try {
      for (let i = 0; i < numRows; i++) {
        const actualRowNumber = startRow + i;
        if (sheet.isRowHiddenByFilter(actualRowNumber) || sheet.isRowHiddenByUser(actualRowNumber)) {
          return true;
        }
      }
    } catch (e) {
      Logger.log('Fallback check for hidden rows failed: ' + e.message);
      return false;
    }
    return false;
  }

  const startRow = range.getRow();
  const numRows = range.getNumRows();

  for (let i = 0; i < numRows; i++) {
    const actualRowIndexInMetadata = startRow + i - 1;
    if (actualRowIndexInMetadata >= 0 && actualRowIndexInMetadata < rowMetadata.length) {
      if (rowMetadata[actualRowIndexInMetadata].hiddenByFilter || rowMetadata[actualRowIndexInMetadata].hiddenByUser) {
        return true;
      }
    }
  }
  return false;
}

function convertToScatteredSelection(range) {
  const sheet = range.getSheet();
  const startRow = range.getRow();
  const numRows = range.getNumRows();

  let visibleCells = [];
  const allValuesInSelectedRange = range.getValues();
  const rowMetadata = getSheetRowMetadata(sheet);

  for (let i = 0; i < numRows; i++) {
    const actualRowNumber = startRow + i;
    const actualRowIndexInMetadata = actualRowNumber - 1;

    if (actualRowIndexInMetadata >= 0 && actualRowIndexInMetadata < rowMetadata.length &&
        !(rowMetadata[actualRowIndexInMetadata].hiddenByFilter || rowMetadata[actualRowIndexInMetadata].hiddenByUser)) {

      const rowData = allValuesInSelectedRange[i];
      const cleanedCells = rowData.map(val => cleanCellData(val)).filter(val => val !== '');
      const processedRow = cleanedCells.join(' | ');
      if (processedRow !== '') visibleCells.push({ rowNumber: actualRowNumber, data: processedRow });
    }
  }

  return visibleCells;
}

function getVisibleCellsOnly(ranges) {
  let visibleData = [];

  ranges.forEach(range => {
    if (hasHiddenRowsInRange(range)) {
      const scatteredCells = convertToScatteredSelection(range);
      visibleData = visibleData.concat(scatteredCells);
    } else {
      const values = range.getValues();
      const startRow = range.getRow();

      values.forEach((row, rowIndex) => {
        const actualRowNumber = startRow + rowIndex;
        const cleanedCells = row.map(cellValue => cleanCellData(cellValue)).filter(cleanValue => cleanValue !== '');
        const processedRow = cleanedCells.join(' | ');
        if (processedRow !== '') visibleData.push({ rowNumber: actualRowNumber, data: processedRow });
      });
    }
  });

  return visibleData;
}

function getVisibleCellsForActionWithRowNumbers(range) {
  const sheet = range.getSheet();
  const rowMetadata = getSheetRowMetadata(sheet);

  let hasActiveFilterOrHiddenRows = false;
  if (rowMetadata && rowMetadata.length > 0) {
    for (let i = 0; i < rowMetadata.length; i++) {
      if (rowMetadata[i].hiddenByFilter || rowMetadata[i].hiddenByUser) {
        hasActiveFilterOrHiddenRows = true;
        break;
      }
    }
  }

  const startRow = range.getRow();
  const numRows = range.getNumRows();
  const allValuesInSelectedRange = range.getValues();

  let visibleRowsAndNumbers = [];

  if (!hasActiveFilterOrHiddenRows) {
    for (let i = 0; i < numRows; i++) {
      visibleRowsAndNumbers.push({
        data: allValuesInSelectedRange[i],
        rowNumber: startRow + i
      });
    }
    return visibleRowsAndNumbers;
  }

  for (let i = 0; i < numRows; i++) {
    const actualRowNumber = startRow + i;
    const actualRowIndexInMetadata = actualRowNumber - 1;

    if (actualRowIndexInMetadata >= 0 && actualRowIndexInMetadata < rowMetadata.length &&
        !(rowMetadata[actualRowIndexInMetadata].hiddenByFilter || rowMetadata[actualRowIndexInMetadata].hiddenByUser)) {
      visibleRowsAndNumbers.push({
        data: allValuesInSelectedRange[i],
        rowNumber: actualRowNumber
      });
    }
  }
  return visibleRowsAndNumbers;
}

function processRealUniverseArray(prompt, preset, temperature) {
  try {
    const systemMessage = getRealUniverseSystemMessage(getDynamicPresetSystemMessage(preset, 'array'), 'array');
    const config = MODEL_CONFIG.array;
    const rangeList = SpreadsheetApp.getActiveRangeList();
    if (!rangeList) return [['‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ã‡∏•‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å']];

    const ranges = rangeList.getRanges();
    if (ranges.length === 0) return [['‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå']];

    const ui = SpreadsheetApp.getUi();
    const userResponse = ui.prompt("‡∏£‡∏∞‡∏ö‡∏∏‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå (‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ ‡πÄ‡∏ä‡πà‡∏ô D):");
    if (userResponse.getSelectedButton() !== ui.Button.OK) return [['‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô']];

    const targetCol = convertToColumnNumber(userResponse.getResponseText());
    if (!targetCol || isNaN(targetCol)) {
      ui.alert("‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
      return [['‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á']];
    }

    let sheetRef = ranges[0].getSheet();

    let allRowsData = getVisibleCellsOnly(ranges);

    if (allRowsData.length === 0) return [['‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå']];
    if (allRowsData.length > MAX_TOTAL_ROWS_ARRAY) {
      return [['‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏ñ‡∏ß‡∏°‡∏≤‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡πÄ‡∏Å‡∏¥‡∏ô ' + MAX_TOTAL_ROWS_ARRAY + ' ‡πÅ‡∏ñ‡∏ß)']];
    }

    const batchSize = Math.min(MAX_ROWS_PER_BATCH_ARRAY, allRowsData.length);
    const numBatches = Math.ceil(allRowsData.length / batchSize);
    const allResults = new Array(allRowsData.length).fill('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÑ‡∏î‡πâ');

    for (let batchIndex = 0; batchIndex < numBatches; batchIndex++) {
      const startIndex = batchIndex * batchSize;
      const endIndex = Math.min(startIndex + batchSize, allRowsData.length);
      const currentBatch = allRowsData.slice(startIndex, endIndex);

      const batchDataForAI = currentBatch.map(item => '‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà ' + item.rowNumber + ': ' + item.data).join('\n');

      const enhancedSystemMessage = systemMessage + '\n\nReturn JSON array format: [{"row": <number>, "result": "<analysis_result>"}]\nMust have exactly ' + currentBatch.length + ' results.';

      const content = prompt + '\n\n‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå:\n' + batchDataForAI + '\n\nReturn JSON array with ' + currentBatch.length + ' results.';

      const payload = {
        model: config.model,
        messages: [
          { role: 'system', content: enhancedSystemMessage },
          { role: 'user', content: content }
        ],
        temperature: temperature,
        max_tokens: config.max_tokens
      };

      try {
        const rawResult = makeRealUniverseApiCall(payload);
        let cleanedResponse = rawResult.trim();

        if (cleanedResponse.startsWith('```json')) {
          cleanedResponse = cleanedResponse.replace(/^```json\s*/, '').replace(/\s*```$/, '');
        }

        const batchResults = JSON.parse(cleanedResponse);

        batchResults.forEach(item => {
          const originalItemIndex = allRowsData.findIndex(data => data.rowNumber === item.row);
          if (originalItemIndex !== -1) {
            allResults[originalItemIndex] = item.result || '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÑ‡∏î‡πâ';
          }
        });

      } catch (e) {
        currentBatch.forEach(item => {
          const originalItemIndex = allRowsData.findIndex(data => data.rowNumber === item.rowNumber);
          if (originalItemIndex !== -1) {
            allResults[originalItemIndex] = '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏î‡πâ';
          }
        });
        Logger.log(`Error processing batch: ${e.message}`);
      }

      currentBatch.forEach(item => {
        const originalItemIndex = allRowsData.findIndex(data => data.rowNumber === item.rowNumber);
        if (originalItemIndex !== -1) {
          try {
            const targetCell = sheetRef.getRange(item.rowNumber, targetCol, 1, 1);
            targetCell.setValue(allResults[originalItemIndex]);
          } catch (e) {
            Logger.log('Error writing to cell ' + item.rowNumber + ', ' + targetCol + ': ' + e.message);
          }
        }
      });

      SpreadsheetApp.flush();
      if (batchIndex < numBatches - 1) Utilities.sleep(500);
    }

    return [['‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ñ‡∏π‡∏Å‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏£‡∏∞‡∏ö‡∏∏ (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô ' + allRowsData.length + ' ‡πÅ‡∏ñ‡∏ß)']];

  } catch (error) {
    Logger.log('Error in processRealUniverseArray: ' + error.toString());
    return [['‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.toString()]];
  }
}

function processRealUniverseImage(prompt, preset, temperature) {
  try {
    const config = MODEL_CONFIG.image;

    let contextData = '';
    const rangeList = SpreadsheetApp.getActiveRangeList();
    if (rangeList) {
      const ranges = rangeList.getRanges();
      ranges.forEach(range => {
        const values = range.getValues();
        values.forEach(row => {
          const cellText = row.filter(cell => cell !== '').join(' ');
          if (cellText) contextData += cellText + ' ';
        });
      });
    }

    const promptTemplate = getRealUniverseSystemMessage(getDynamicPresetSystemMessage(preset, 'image'), 'image');

    const analysisPayload = {
      model: 'gpt-4.1',
      messages: [
        { role: 'system', content: promptTemplate },
        { role: 'user', content: `‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á detailed prompt ‡∏à‡∏≤‡∏Å‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤: "${contextData.trim()}"` }
      ],
      temperature: temperature,
      max_tokens: 2000
    };

    const detailedPrompt = makeRealUniverseApiCall(analysisPayload);

    const imagePayload = {
      model: config.model,
      prompt: detailedPrompt,
      size: config.size,
      quality: config.quality,
      n: config.n
    };

    const result = makeRealUniverseImageApiCall(imagePayload);

    const combinedPrompt = contextData ? `${prompt}: ${contextData.trim()}` : prompt;

    const downloadUrl = insertImageToSheet(result.imageUrl, combinedPrompt);

    if (downloadUrl) {
      const message = `üé® ‡∏†‡∏≤‡∏û‡∏ñ‡∏π‡∏Å‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!\n\nüì• ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î: ${downloadUrl}`;
      saveRealUniverseHistory(prompt + ' (Smart Image)', message);
      return message;
    } else {
      throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏ó‡∏£‡∏Å‡∏†‡∏≤‡∏û‡πÉ‡∏ô‡∏ä‡∏µ‡∏ï‡πÑ‡∏î‡πâ');
    }

  } catch (error) {
    Logger.log('Error in processRealUniverseImage: ' + error.toString());
    return '‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏†‡∏≤‡∏û: ' + error.toString();
  }
}
/* ------------------ API AND HELPER FUNCTIONS ------------------ */

function getApiTypeForModel(modelName) {
  if (!modelName) return 'chat';
  const m = String(modelName).toLowerCase();

  const isGpt5 = m.startsWith('gpt-5');
  const isCodexMini = m.includes('codex-mini');
  const isOseries = m.startsWith('o');
  const isGpt5Codex = m.includes('gpt-5-codex');

  if (isGpt5 || isCodexMini || isOseries || isGpt5Codex) return 'responses';
  return 'chat';
}

function buildRequestBodyForApi(apiType, payload) {
  const { model, messages, temperature, max_tokens, response_format } = payload || {};
  if (apiType === 'responses') {
    const body = {
      model: model,
      input: messages
    };
    if (typeof max_tokens !== 'undefined') {
      body.max_output_tokens = max_tokens;
    }
    if (response_format) {
      body.response_format = response_format;
    }
    return body;
  } else {
    const body = {
      model: model,
      messages: messages
    };
    if (typeof temperature !== 'undefined') {
      body.temperature = temperature;
    }
    if (typeof max_tokens !== 'undefined') {
      body.max_tokens = max_tokens;
    }
    if (response_format) {
      body.response_format = response_format;
    }
    return body;
  }
}

function extractTextFromApiResponse(apiType, resJson) {
  try {
    if (apiType === 'responses') {
      if (typeof resJson.output_text === 'string' && resJson.output_text.trim() !== '') {
        return resJson.output_text.trim();
      }
      if (Array.isArray(resJson.output)) {
        const texts = [];
        resJson.output.forEach(part => {
          if (part && Array.isArray(part.content)) {
            part.content.forEach(c => {
              if (c && typeof c.text === 'string') texts.push(c.text);
            });
          }
        });
        if (texts.length) return texts.join('').trim();
      }
      if (Array.isArray(resJson.content)) {
        const texts = [];
        resJson.content.forEach(c => {
          if (c && typeof c.text === 'string') texts.push(c.text);
          if (c && Array.isArray(c.content)) {
            c.content.forEach(cc => {
              if (cc && typeof cc.text === 'string') texts.push(cc.text);
            });
          }
        });
        if (texts.length) return texts.join('').trim();
      }
      return JSON.stringify(resJson);
    } else {
      if (resJson && resJson.choices && resJson.choices[0] && resJson.choices[0].message) {
        const out = resJson.choices[0].message.content;
        if (typeof out === 'string') return out.trim();
      }
      return JSON.stringify(resJson);
    }
  } catch (e) {
    Logger.log('extractTextFromApiResponse error: ' + e.message);
    return JSON.stringify(resJson);
  }
}

function makeRealUniverseApiCall(payload) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('REALUNIVERSE_API_KEY');
  if (!apiKey) throw new Error('API Key not set. Please use the menu to set it up.');

  const apiType = getApiTypeForModel(payload && payload.model);
  const endpoint = apiType === 'responses' ? RESPONSES_API_URL : API_URL;
  const requestBody = buildRequestBodyForApi(apiType, payload);

  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { 'Authorization': 'Bearer ' + apiKey },
    payload: JSON.stringify(requestBody),
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(endpoint, options);
  const status = response.getResponseCode();
  const bodyText = response.getContentText();
  let res;
  try {
    res = JSON.parse(bodyText);
  } catch (err) {
    throw new Error('API Response parse error: ' + bodyText);
  }

  if (status >= 400) {
    const errMsg = res && res.error && res.error.message ? res.error.message : bodyText;
    throw new Error('API Error: ' + errMsg);
  }

  const text = extractTextFromApiResponse(apiType, res);
  if (!text || !String(text).trim()) {
    throw new Error('Invalid response from AI.');
  }
  return String(text).trim();
}

function makeRealUniverseApiCallWithRetry(payload, maxRetries) {
  if (typeof maxRetries === 'undefined') maxRetries = 2;
  let lastError;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return makeRealUniverseApiCall(payload);
    } catch (error) {
      lastError = error;
      Logger.log(`API call attempt ${attempt + 1} failed: ${error.message}`);

      if (attempt < maxRetries) {
        const delayMs = Math.pow(2, attempt) * 1000;
        Utilities.sleep(delayMs);
      }
    }
  }

  throw new Error(`API call failed after ${maxRetries + 1} attempts. Last error: ${lastError.message}`);
}

function makeRealUniverseImageApiCall(payload) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('REALUNIVERSE_API_KEY');
  if (!apiKey) throw new Error('API Key not set. Please use the menu to set it up.');

  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: { 'Authorization': 'Bearer ' + apiKey },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  const response = UrlFetchApp.fetch(IMAGE_API_URL, options);
  const res = JSON.parse(response.getContentText());

  if (response.getResponseCode() >= 400) {
    throw new Error('Image API Error: ' + (res.error ? res.error.message : response.getContentText()));
  }

  if (!res.data || !res.data[0] || !res.data[0].url) {
    throw new Error('Invalid response from Image API.');
  }

  return {
    imageUrl: res.data[0].url,
    revisedPrompt: res.data[0].revised_prompt || payload.prompt
  };
}

function insertImageToSheet(imageUrl, description) {
  try {
    const response = UrlFetchApp.fetch(imageUrl);
    let blob = response.getBlob();

    blob = Utilities.newBlob(
      blob.getBytes(),
      'image/jpeg',
      'resized_image.jpg'
    );

    let folder;
    const folders = DriveApp.getFoldersByName('RealUniverse Images');
    if (folders.hasNext()) {
      folder = folders.next();
    } else {
      folder = DriveApp.createFolder('RealUniverse Images');
    }

    const file = folder.createFile(blob.setName('RealUniverse_' + new Date().getTime() + '.jpg'));

    const thumbnailBlob = blob.setName('thumb_' + new Date().getTime() + '.jpg');

    const sheet = SpreadsheetApp.getActiveSheet();
    sheet.insertImage(thumbnailBlob, 1, 3);

    return file.getUrl();

  } catch (error) {
    Logger.log('Error: ' + error.toString());
    return false;
  }
}

function getRealUniverseSystemMessage(cellReference, mode) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Preset');

  if (!sheet) {
    throw new Error('‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö Sheet "Preset" ‡πÇ‡∏õ‡∏£‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á Sheet ‡∏ä‡∏∑‡πà‡∏≠ "Preset" ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
  }

  try {
    if (cellReference.includes('Preset!')) {
      const cellAddr = cellReference.split('!')[1];
      const value = sheet.getRange(cellAddr).getValue();
      if (value && String(value).trim()) {
        return String(value).trim();
      } else {
        throw new Error(`‚ùå ‡πÄ‡∏ã‡∏•‡∏•‡πå ${cellReference} ‡πÉ‡∏ô Sheet "Preset" ‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤`);
      }
    }
  } catch (e) {
    if (e.message.includes('‚ùå')) throw e;
    throw new Error('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô Sheet "Preset": ' + e.message);
  }

  if (mode === 'array') {
    return 'You are an AI that analyzes data and returns results in JSON format. For each row of input data, provide a JSON object in the format {"row": <row_number>, "result": "<analysis_result>"}. Return an array of these objects.';
  } else if (mode === 'image') {
    return 'Create a detailed image based on this description: {prompt}';
  } else {
    return 'You are a helpful AI assistant that analyzes spreadsheet data and provides insights in Thai language.';
  }
}

function chunkDataByCharLimit(lines, charLimit) {
  if (!lines || lines.length === 0) return [];

  const chunks = [];
  let currentChunkLines = [];
  let currentCharCount = 0;

  for (const line of lines) {
    const processedLine = line.trim() === '' ? '(‡πÅ‡∏ñ‡∏ß‡∏ß‡πà‡∏≤‡∏á)' : line;
    const lineLength = processedLine.length + 1;

    if (currentCharCount + lineLength > charLimit && currentChunkLines.length > 0) {
      chunks.push(currentChunkLines.join('\n'));
      currentChunkLines = [processedLine];
      currentCharCount = lineLength;
    } else {
      currentChunkLines.push(processedLine);
      currentCharCount += lineLength;
    }
  }

  if (currentChunkLines.length > 0) {
    chunks.push(currentChunkLines.join('\n'));
  }

  return chunks;
}

function cleanCellData(cellValue) {
  if (cellValue == null || cellValue === '') return '';

  return String(cellValue)
    .replace(/[\x00-\x1F\x7F-\x9F\u200B-\u200D\uFEFF]/g, '')
    .replace(/[\r\n]+/g, ' ')
    .replace(/[|:]/g, ' ')
    .replace(/&[a-zA-Z0-9#]+;/g, ' ')
    .replace(/["""'']/g, '"')
    .replace(/\s+/g, ' ')
    .trim()
    .replace(/^["']|["']$/g, '');
}

function convertToColumnNumber(input) {
  input = String(input).toUpperCase().trim();
  if (!isNaN(input) && Number(input) > 0) return parseInt(input, 10);
  let result = 0;
  for (let i = 0; i < input.length; i++) {
    result = result * 26 + (input.charCodeAt(i) - 'A'.charCodeAt(0) + 1);
  }
  return result > 0 ? result : null;
}

/* ------------------ UTILITY FUNCTIONS ------------------ */

function saveRealUniverseHistory(question, answer) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(CHAT_SHEET_NAME);
    if (!sheet) {
      sheet = ss.insertSheet(CHAT_SHEET_NAME);
      sheet.getRange('A1:D1').setValues([['Timestamp', 'Question', 'Answer', 'Selected Cells']]).setFontWeight('bold');
    }
    const selection = getRealUniverseSelectedCellInfo();
    sheet.appendRow([new Date(), question, String(answer), selection]);
  } catch (e) {
    Logger.log('Error saving history: ' + e.message);
  }
}

function clearRealUniverseHistory() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert('Confirm Clear', 'Clear all chat history?', ui.ButtonSet.YES_NO);
  if (response === ui.Button.YES) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CHAT_SHEET_NAME);
    if (sheet) {
      sheet.clearContents().getRange('A1:D1')
        .setValues([['Timestamp', 'Question', 'Answer', 'Selected Cells']])
        .setFontWeight('bold');
      ui.alert('Success', 'Chat history cleared.', ui.ButtonSet.OK);
    }
  }
}

function getRealUniverseSelectedCellInfo() {
  try {
    const rangeList = SpreadsheetApp.getActiveSpreadsheet().getActiveRangeList();
    if (rangeList) {
      const ranges = rangeList.getRanges();
      const sheetName = ranges[0].getSheet().getName();
      if (ranges.length > 1) {
        return sheetName + '!' + ranges.map(r => r.getA1Notation()).join(', ');
      } else if (ranges.length === 1) {
        const r = ranges[0];
        return sheetName + '!' + r.getA1Notation() + ' (' + r.getNumRows() + ' rows, ' + r.getNumColumns() + ' cols)';
      }
    }
    return '(No cells selected)';
  } catch (e) {
    return '(Error reading selection)';
  }
}

function getRealUniverseHtmlContent() {
  return `<!DOCTYPE html>
<html lang="th">
<head>
<base target="_top">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RealUniverse AI</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    background: #f5f5f7;
    height: 100vh;
    width: 100vw;     
    margin: 0;        
    padding: 0;      
    overflow: hidden;
}
.container {
    height: 100%;
    width: 100%;      
    display: flex;
    flex-direction: column;
    background: white;
    position: relative;
}
.mode-switch-button {
    position: absolute;
    top: 8px;
    right: 8px;
    background: transparent;
    border: none;
    color: #86868b;
    font-size: 12px;
    cursor: pointer;
    padding: 6px 8px;
    border-radius: 6px;
    outline: none;
    transition: all 0.2s ease;
    z-index: 1000;
    display: flex;
    align-items: center;
    gap: 4px;
}
.mode-switch-button:hover {
    color: #1d1d1f;
    background: #f8f9fa;
}
.chat-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
.messages {
    flex: 1;
    overflow-y: auto;
    padding: 16px 12px;
    background: #F0FFFF;
    scroll-behavior: smooth;
}
.message {
    margin-bottom: 12px;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    position: relative;
}
.message.user {
    align-items: flex-end;
}
.message-content {
    max-width: 100%;
    padding: 10px 14px;
    border-radius: 18px;
    font-size: 12px;
    line-height: 1.3;
    word-wrap: break-word;
    word-break: break-word;
    white-space: pre-wrap;
    position: relative;
}
.message.user .message-content {
    background: #E6E6FA;
    color: #1d1d1f;
    border-bottom-right-radius: 4px;
}
.message.bot .message-content {
    background: #F0FFFF;
    color: #1d1d1f;
    border-bottom-left-radius: 4px;
}
.message-content strong {
    font-weight: 600;
    color: #1d1d1f;
}

.thinking-box {
    width: 100%;
    margin-bottom: 8px;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    background: #fefefe;
    overflow: hidden;
}
.thinking-header {
    padding: 8px 12px;
    background: #f8f9fa;
    border-bottom: 1px solid #e5e5e7;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    user-select: none;
}
.thinking-title {
    font-size: 11px;
    font-weight: 500;
    color: #1d1d1f;
}
.thinking-toggle {
    font-size: 10px;
    color: #86868b;
}
.thinking-content {
    padding: 12px;
    font-size: 11px;
    line-height: 1.5;
    color: #1d1d1f;
    max-height: 300px;
    overflow-y: auto;
    white-space: pre-wrap;
}
.thinking-content.collapsed {
    display: none;
}

.copy-button {
    position: absolute;
    bottom: 4px;
    right: 4px;
    background: transparent;
    border: none;
    border-radius: 4px;
    width: 26px;
    height: 26px;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    color: #86868b;
    transition: all 0.2s ease;
    z-index: 10;
}
.copy-button:hover {
    background: transparent;
    color: #1d1d1f;
}
.copy-button.copied {
    background: transparent;
    color: #059669;
}
.message.bot.typing-finished .copy-button {
    display: flex;
}

.tooltip {
    position: relative;
}
.tooltip:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    background: #1d1d1f;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    white-space: nowrap;
    z-index: 1000;
    opacity: 1;
    pointer-events: none;
}
.tooltip:hover::before {
    content: '';
    position: absolute;
    bottom: calc(100% + 2px);
    left: 50%;
    transform: translateX(-50%);
    border: 4px solid transparent;
    border-top-color: #1d1d1f;
    z-index: 1000;
    opacity: 1;
    pointer-events: none;
}

.input-area {
    background: #F0FFFF;
    padding: 16px 16px 0 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
}

.sidebar-mode .expanded-input-container {
    max-width: none;
    width: 100%;
}
.sidebar-mode .turbo-wrapper {
    max-width: none;
    width: 100%;
}
.sidebar-mode .quick-actions-buttons {
    flex-direction: row;
    justify-content: center;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
}
.sidebar-mode .quick-action-btn {
    border-radius: 12px;
    text-align: center;
    flex: none;
}

.sidebar-mode .in-box-controls {
    flex-wrap: wrap;
    gap: 4px;
}

.sidebar-mode .status-text {
    font-size: 9px;
    padding: 3px 6px;
}

.sidebar-mode .turbo-toggle {
    font-size: 9px;
    padding: 3px 6px;
}

.sidebar-mode .hamburger-btn {
    padding: 3px 6px;
    font-size: 10px;
}

.sidebar-mode .sendButton {
    width: 28px;
    height: 28px;
}

.custom-title-bar {
    background: #F0FFFF;
    border-bottom: none;
    padding: 12px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
}
.app-title {
    background: linear-gradient(45deg, #8360c3, #2ebf91, #8360c3);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-family: 'Roboto', sans-serif;
    font-weight: 500;
    font-size: 20px;
    letter-spacing: 0.3px;
    margin: 0;
    padding-left: 40px;
    position: relative;
}

.app-title::before {
    content: '';
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 40px;
    height: 40px;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="%238360c3" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M14.826 5.376c2.8-1.995 5.087-2.882 5.883-2.085c.797.796-.09 3.083-2.085 5.884m-13.248 5.65c-1.995 2.8-2.882 5.088-2.085 5.884c.796.797 3.083-.09 5.884-2.085m9.45-9.45c-1.133 1.59-2.622 3.345-4.364 5.087s-3.497 3.231-5.086 4.363m9.45-9.45A7.2 7.2 0 0 1 19.2 12a7.2 7.2 0 0 1-10.025 6.624M17.09 6.91A7.2 7.2 0 1 0 6.91 17.09" color="%238360c3"/></svg>');
    background-size: contain;
    background-repeat: no-repeat;
}

.turbo-wrapper {
    position: relative;
    width: 100%;
    max-width: 400px;
    display: flex;
    justify-content: flex-start;
    margin-bottom: 4px;
}
.turbo-container {
    display: flex;
    align-items: center;
    justify-content: flex-start;
}
.turbo-toggle {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    border-radius: 6px;
    background: transparent;
    border: 1px solid #d1d5db;
    cursor: pointer;
    font-size: 10px;
    color: #86868b;
    outline: none;
    transition: all 0.2s ease;
}
.turbo-toggle.active {
    background: #b3e5fc;
    color: #1d1d1f;
}
.turbo-status {
    font-size: 9px;
    color: #86868b;
    margin-left: 8px;
}

.send-button {
    background: white;
    color: white;
    border: 2px solid #e5e5e7;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    flex-shrink: 0;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg');
    background-size: 26px 26px;
    background-repeat: no-repeat;
    background-position: center;
    transition: all 0.2s ease;
}
.send-button:hover {
    background-color: #f8f9fa;
    border-color: #d1d5db;
    transform: scale(1.05);
}
.send-button:disabled {
    background-color: #f5f5f5;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg');
    border-color: #e5e5e7;
    cursor: not-allowed;
    opacity: 0.6;
}
.send-button:disabled.spinning {
    animation: spin 1s linear infinite !important;
    background-color: #f5f5f5 !important;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg') !important;
    border-color: #e5e5e7 !important;
    cursor: not-allowed !important;
    opacity: 0.6 !important;
}
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.send-button.spinning {
    animation: spin 1s linear infinite;
}

.expanded-input-container {
    width: 100%;
    max-width: 400px;
    display: flex;
    align-items: stretch;
    background: white;
    border: 1px solid #E6E6FA;
    border-radius: 20px;
    padding: 6px 12px;
    margin-bottom: 8px;
    position: relative;
}

.input-content {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.message-input {
    width: 100%;
    border: none;
    background: transparent;
    padding: 10px 0 0 0;
    font-size: 12px;
    outline: none;
    resize: none;
    max-height: 100px;
    min-height: 24px;
    line-height: 1.4;
    font-family: inherit;
    color: #1d1d1f;
    overflow-y: auto;
    scrollbar-width: none;
}
.message-input::-webkit-scrollbar {
    display: none;
}
.message-input::placeholder {
    color: #86868b;
}

.in-box-controls {
   display: flex;
   align-items: center;
   gap: 8px;
   margin-top: 14px;
   padding: 4px 0 8px 0;
   position: relative;
}

.hamburger-btn {
    background: transparent;
    border: 1px solid #d1d5db;
    color: #86868b;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 4px;
    font-size: 12px;
    transition: all 0.2s ease;
}

.hamburger-btn:hover {
    background: rgba(255,255,255,0.5);
    color: #1d1d1f;
}

.status-text {
    font-size: 10px;
    color: #86868b;
    border: 1px solid #d1d5db;
    padding: 4px 8px;
    border-radius: 4px;
}

.sendButton {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 1px solid #E6E6FA;
    background: white;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 8px;
    flex-shrink: 0;
    align-self: flex-end;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg');
    background-size: 26px 26px;
    background-repeat: no-repeat;
    background-position: center;
    transition: all 0.2s ease;
}

.sendButton:hover {
    background-color: white;
    transform: scale(1.05);
}

.sendButton:disabled {
    background-color: #f5f5f5;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg');
    border-color: #e5e5e7;
    cursor: not-allowed;
    opacity: 0.6;
}

.sendButton:disabled.spinning {
    animation: spin 1s linear infinite !important;
    background-color: #f5f5f5 !important;
    background-image: url('https://i.ibb.co/vvCrQ8DW/RS.jpg') !important;
    border-color: #e5e5e7 !important;
    cursor: not-allowed !important;
    opacity: 0.6 !important;
}

.sendButton.spinning {
    animation: spin 1s linear infinite;
}

.settings-popup {
    position: absolute;
    bottom: calc(100% + 8px);
    left: 0;
    background: white;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    padding: 16px;
    width: 320px;
    max-height: 350px;
    overflow-y: auto;
    display: none;
    z-index: 1000;
}

.settings-popup.show {
    display: block;
}

.popup-section {
    margin-bottom: 12px;
}

.popup-title {
    font-size: 12px;
    font-weight: 600;
    color: #1d1d1f;
    margin-bottom: 6px;
}

.popup-options {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
}

.popup-option {
    padding: 4px 8px;
    background: #f8f9fa;
    border: 1px solid #e5e5e7;
    border-radius: 6px;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.popup-option:hover {
    background: #e5e5e7;
}

.popup-option.active {
    background: #8360c3;
    color: white;
    border-color: #8360c3;
}

.array-info {
    background: #F0FFFF;
    padding: 6px 8px;
    border-radius: 4px;
    font-size: 10px;
    color: #0066cc;
    border: 1px solid #F0FFFF;
    margin-top: -4px;
}
.messages::-webkit-scrollbar {
    width: 4px;
}
.messages::-webkit-scrollbar-track {
    background: transparent;
}
.messages::-webkit-scrollbar-thumb {
    background: #c7c7cc;
    border-radius: 4px;
}
.typing-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 10px 14px;
    background: white;
    border-radius: 18px;
    border-bottom-left-radius: 4px;
}
.typing-dot {
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: #86868b;
    animation: typing 1.4s infinite;
}
.typing-dot:nth-child(2) {
    animation-delay: 0.2s;
}
.typing-dot:nth-child(3) {
    animation-delay: 0.4s;
}
@keyframes typing {
    0%, 60%, 100% {
        transform: translateY(0);
        opacity: 0.4;
    }
    30% {
        transform: translateY(-4px);
        opacity: 1;
    }
}
.empty-state {
    text-align: center;
    color: #86868b;
    font-size: 14px;
    padding: 0;
    line-height: 1.5;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
}

.quick-actions {
    padding: 8px 16px 12px 16px;
    background: transparent;
}
.quick-actions-label {
    font-size: 11px;
    color: #86868b;
    margin-bottom: 0;
    text-align: center;
    cursor: pointer;
    transition: color 0.2s ease;
}
.quick-actions:hover .quick-actions-buttons {
    opacity: 1;
    max-height: 100px;
    margin-top: 8px;
}

.quick-actions:hover .quick-actions-label {
    color: #1d1d1f;
}
.quick-actions-buttons {
    display: flex;
    justify-content: center;
    gap: 8px;
    flex-wrap: wrap;
    opacity: 0;
    max-height: 0;
    overflow: hidden;
    transition: all 0.3s ease;
}
.quick-action-btn {
    background: #1d1d1f;
    border: 1px solid #1d1d1f;
    border-radius: 16px;
    padding: 3px 7px;
    font-size: 7px;
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    outline: none;
    font-family: inherit;
}
.quick-action-btn:hover {
    background: #2d2d2f;
    border-color: #2d2d2f;
    transform: translateY(-1px);
}
.quick-action-btn:active {
    transform: translateY(0);
    background: #0d0d0f;
}
</style>
</head>
<body>
<div class="container" id="main-container">
    <div class="custom-title-bar">
        <div class="app-title">Real Universe Agentic</div>
        <button class="mode-switch-button" id="mode-switch-button" onclick="toggleDisplayMode()">
            ‚ñ¢‚ñ£
        </button>
    </div>
    
    <div class="chat-container">
        <div class="messages" id="messages">
            <div class="empty-state">Intelligent insights for your Google Sheets</div>
        </div>
    </div>

    <div class="input-area">
        <div class="quick-actions" id="quick-actions">
            <div class="quick-actions-label">Quick Action</div>
            <div class="quick-actions-buttons">
                <button class="quick-action-btn" onclick="sendQuickAction('‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•')">‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</button>
                <button class="quick-action-btn" onclick="sendQuickAction('‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô')">‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô</button>
                <button class="quick-action-btn" onclick="sendQuickAction('‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç')">‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç</button>
            </div>
        </div>

        <div class="expanded-input-container">
            <div class="input-content">
                <textarea
                    class="message-input"
                    id="messageInput"
                    placeholder="Ask me anything.."
                    rows="1"
                ></textarea>
                
                <div class="in-box-controls">
                    <button class="hamburger-btn" onclick="toggleSettingsPopup()">Settings</button>
                    <span class="status-text" id="statusText">Answer ‚Ä¢ Loading... ‚Ä¢ Exact</span>
                    <button class="turbo-toggle" id="turbo-toggle" onclick="toggleTurbo()" style="display: none;">Deep</button>
                    
                    <div class="settings-popup" id="settingsPopup">
                        <div class="popup-section">
                            <div class="popup-title">Mode</div>
                            <div class="popup-options">
                                <div class="popup-option active" onclick="selectPopupMode('Answer', this, 'action')">Answer</div>
                                <div class="popup-option" onclick="selectPopupMode('Array', this, 'array')">Array</div>
                                <div class="popup-option" onclick="selectPopupMode('Create Picture', this, 'image')">Create Picture</div>
                            </div>
                        </div>
                        
                        <div class="popup-section">
                            <div class="popup-title">Preset</div>
                            <div class="popup-options" id="popupPresetOptions">
                                <div style="padding: 12px; text-align: center; font-size: 10px; color: #86868b;">
                                    Loading presets...
                                </div>
                            </div>
                        </div>
                        
                        <div class="popup-section">
                            <div class="popup-title">AI Creativity</div>
                            <div class="popup-options">
                                <div class="popup-option active" onclick="selectPopupTemp('Exact', this, 0)">Exact</div>
                                <div class="popup-option" onclick="selectPopupTemp('Focused', this, 0.2)">Focused</div>
                                <div class="popup-option" onclick="selectPopupTemp('Balance', this, 0.5)">Balance</div>
                                <div class="popup-option" onclick="selectPopupTemp('Creative', this, 0.7)">Creative</div>
                            </div>
                        </div>

                        <div class="popup-section">
                            <div class="popup-title">Thinking Mode</div>
                            <div class="popup-options">
                                <div class="popup-option" id="thinkingModeToggle" onclick="toggleThinkingMode(this)">OFF</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <button class="sendButton" id="sendButton" onclick="sendMessage()"></button>
        </div>
        
        <div id="selected-cell" class="array-info">Selected: No data selected</div>
    </div>
</div>
<script>
let currentMode = 'action';
let currentPreset = null;
let currentTemperature = 0;
let isTyping = false;
let currentTypingElement = null;
let currentTypingText = '';
let turboMode = false;
let thinkingMode = false;

let dynamicPresets = null;
let presetDescriptions = {};

function parseMarkdown(text) {
   return text.replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>');
}

function convertLinksToClickable(text) {
   return text.replace(/(https?:\\/\\/[^\\s<>]+)/g, 
       '<a href="$1" target="_blank" style="color: #0066cc; text-decoration: underline;">Link</a>');
}

function copyToClipboard(text, button) {
   try {
       const tempDiv = document.createElement('div');
       tempDiv.innerHTML = text;
       const plainText = tempDiv.textContent || tempDiv.innerText || '';
       
       navigator.clipboard.writeText(plainText).then(() => {
           button.innerHTML = '‚òë';
           button.classList.add('copied');
           button.setAttribute('data-tooltip', 'Copied!');
           
           setTimeout(() => {
               button.innerHTML = 'üóí';
               button.classList.remove('copied');
               button.setAttribute('data-tooltip', 'Copy');
           }, 2000);
       }).catch(() => {
           const textArea = document.createElement('textarea');
           textArea.value = plainText;
           textArea.style.position = 'fixed';
           textArea.style.opacity = '0';
           document.body.appendChild(textArea);
           textArea.select();
           document.execCommand('copy');
           document.body.removeChild(textArea);
           
           button.innerHTML = '‚òë';
           button.classList.add('copied');
           button.setAttribute('data-tooltip', 'Copied!');
           
           setTimeout(() => {
               button.innerHTML = 'üóí';
               button.classList.remove('copied');
               button.setAttribute('data-tooltip', 'Copy');
           }, 2000);
       });
   } catch (error) {
       console.error('Copy failed:', error);
       button.setAttribute('data-tooltip', 'Copy failed');
       setTimeout(() => {
           button.setAttribute('data-tooltip', 'Copy');
       }, 2000);
   }
}

function toggleTurbo() {
   turboMode = !turboMode;
   const turboToggle = document.getElementById('turbo-toggle');

   if (turboMode) {
       turboToggle.classList.add('active');
   } else {
       turboToggle.classList.remove('active');
   }
}

function toggleThinkingMode(element) {
   thinkingMode = !thinkingMode;
   element.textContent = thinkingMode ? 'ON' : 'OFF';
   
   if (thinkingMode) {
       element.classList.add('active');
   } else {
       element.classList.remove('active');
   }
}

function toggleSettingsPopup() {
   const popup = document.getElementById('settingsPopup');
   popup.classList.toggle('show');
}

function selectPopupMode(modeName, element, modeValue) {
   currentMode = modeValue;
   document.querySelectorAll('#settingsPopup .popup-section:nth-child(1) .popup-option').forEach(option => {
       option.classList.remove('active');
   });
   element.classList.add('active');
   updateMode();
   updateStatusText();
}

function selectPopupPreset(presetName, element, presetValue) {
   currentPreset = presetValue;
   document.querySelectorAll('#popupPresetOptions .popup-option').forEach(option => {
       option.classList.remove('active');
   });
   element.classList.add('active');
   updateStatusText();
}

function selectPopupTemp(tempName, element, tempValue) {
   currentTemperature = tempValue;
   document.querySelectorAll('#settingsPopup .popup-section:nth-child(3) .popup-option').forEach(option => {
       option.classList.remove('active');
   });
   element.classList.add('active');
   updateStatusText();
}

function updateStatusText() {
   const mode = document.querySelector('#settingsPopup .popup-section:nth-child(1) .popup-option.active').textContent;
   const preset = document.querySelector('#popupPresetOptions .popup-option.active')?.textContent || 'Loading...';
   const creativity = document.querySelector('#settingsPopup .popup-section:nth-child(3) .popup-option.active').textContent;
   
   const statusText = \`\${mode} ‚Ä¢ \${preset} ‚Ä¢ \${creativity}\`;
   document.getElementById('statusText').textContent = statusText;
}

function loadDynamicPresets() {
   google.script.run
       .withSuccessHandler(presets => {
           dynamicPresets = presets;
           updatePopupPresetsUI(presets);
           loadPresetDescriptions();
       })
       .withFailureHandler(error => {
           console.error('Error loading presets:', error);
           showPopupPresetError(error.message || error.toString());
       })
       .getDynamicPresets();
}

function loadPresetDescriptions() {
   if (!dynamicPresets) return;
   
   const allPresetKeys = [
       ...Object.keys(dynamicPresets.action || {}),
       ...Object.keys(dynamicPresets.array || {})
   ];
   
   allPresetKeys.forEach(key => {
       google.script.run
           .withSuccessHandler(description => {
               presetDescriptions[key] = description;
           })
           .withFailureHandler(() => {
               presetDescriptions[key] = '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢';
           })
           .getPresetDescriptionByKey(key);
   });
}

function updatePopupPresetsUI(presets) {
   const presetContainer = document.getElementById('popupPresetOptions');
   presetContainer.innerHTML = '';

   const currentPresetList = presets[currentMode] || {};
   const presetKeys = Object.keys(currentPresetList)
       .sort((a, b) => currentPresetList[a].ROW_NUMBER - currentPresetList[b].ROW_NUMBER);
   
   if (presetKeys.length === 0) {
       showPopupPresetError(\`No \${currentMode === 'action' ? 'Action' : 'Array'} Presets in Sheet "Preset"\`);
       return;
   }
   
   let presetExists = currentPreset && presetKeys.includes(currentPreset);
   if (!presetExists && presetKeys.length > 0) {
       currentPreset = presetKeys[0];
   }
   
   presetKeys.forEach(key => {
       const preset = currentPresetList[key];
       const option = document.createElement('div');
       option.className = 'popup-option';
       option.textContent = preset.DISPLAY_NAME;
       option.onclick = () => selectPopupPreset(preset.DISPLAY_NAME, option, key);
       
       if (key === currentPreset) {
           option.classList.add('active');
       }
       
       presetContainer.appendChild(option);
   });
   
   updateStatusText();
}

function showPopupPresetError(errorMessage) {
   const presetContainer = document.getElementById('popupPresetOptions');
   presetContainer.innerHTML = \`
       <div style="padding: 12px; color: #dc2626; font-size: 10px; text-align: center; line-height: 1.4;">
           \${errorMessage.replace(/\\n/g, '<br>')}
       </div>
   \`;
   updateStatusText();
}

function updateMode() {
   const turboToggle = document.getElementById('turbo-toggle');
   if (currentMode === 'action') {
       turboToggle.style.display = 'flex';
   } else {
       turboToggle.style.display = 'none';
       turboMode = false;
       turboToggle.classList.remove('active');
   }
   
   loadDynamicPresets();
}

function updateSelectedCell() {
   google.script.run.withSuccessHandler(cellInfo => {
       const selectedCell = document.getElementById('selected-cell');
       selectedCell.textContent = 'Data selected: ' + cellInfo;
   }).getRealUniverseSelectedCellInfo();
}

function addThinkingBox(thinkingText) {
   const messages = document.getElementById('messages');
   
   const thinkingBox = document.createElement('div');
   thinkingBox.className = 'thinking-box';
   thinkingBox.id = 'current-thinking-box';
   
   const header = document.createElement('div');
   header.className = 'thinking-header';
   header.onclick = function() {
       const content = this.nextElementSibling;
       const toggle = this.querySelector('.thinking-toggle');
       content.classList.toggle('collapsed');
       toggle.textContent = content.classList.contains('collapsed') ? '‚ñº' : '‚ñ≤';
   };
   
   const title = document.createElement('div');
   title.className = 'thinking-title';
   title.textContent = 'Thinking Process';
   
   const toggle = document.createElement('div');
   toggle.className = 'thinking-toggle';
   toggle.textContent = '‚ñ≤';
   
   header.appendChild(title);
   header.appendChild(toggle);
   
   const content = document.createElement('div');
   content.className = 'thinking-content';
   content.id = 'thinking-content';
   
   thinkingBox.appendChild(header);
   thinkingBox.appendChild(content);
   
   messages.appendChild(thinkingBox);
   
   typeWriterByWord(content, thinkingText, true);
   
   scrollToBottom();
}

function addMessage(text, sender, animate) {
   if (typeof animate === 'undefined') animate = false;
   
   const messages = document.getElementById('messages');
   const emptyState = messages.querySelector('.empty-state');
   if (emptyState) emptyState.remove();

   const messageDiv = document.createElement('div');
   messageDiv.className = 'message ' + sender;

   const content = document.createElement('div');
   content.className = 'message-content';
   
   if (sender === 'bot') {
       const copyButton = document.createElement('button');
       copyButton.className = 'copy-button tooltip';
       copyButton.innerHTML = 'üóí';
       copyButton.setAttribute('data-tooltip', 'Copy');
       copyButton.onclick = function() {
           copyToClipboard(content.innerHTML, this);
       };
       content.appendChild(copyButton);
   }
   
   if (sender === 'user' || !animate) {
       if (sender === 'bot') {
           const withMarkdown = parseMarkdown(text);
           content.innerHTML = convertLinksToClickable(withMarkdown);
           if (!content.querySelector('.copy-button')) {
               const copyButton = document.createElement('button');
               copyButton.className = 'copy-button tooltip';
               copyButton.innerHTML = 'üóí';
               copyButton.setAttribute('data-tooltip', 'Copy');
               copyButton.onclick = function() {
                   copyToClipboard(content.innerHTML, this);
               };
               content.appendChild(copyButton);
           }
       } else {
           content.textContent = text;
       }
   } else {
       content.innerHTML = '';
       const copyButton = document.createElement('button');
       copyButton.className = 'copy-button tooltip';
       copyButton.innerHTML = 'üóí';
       copyButton.setAttribute('data-tooltip', 'Copy');
       copyButton.onclick = function() {
           copyToClipboard(content.innerHTML, this);
       };
       content.appendChild(copyButton);
   }

   messageDiv.appendChild(content);
   messages.appendChild(messageDiv);

   if (sender === 'bot' && animate) {
       isTyping = true;
       currentTypingElement = content;
       currentTypingText = text;
       updateSendButton();
       typeWriterByWord(content, text, false);
   } else {
       scrollToBottom();
       if (sender === 'bot') {
           messageDiv.classList.add('typing-finished');
       }
   }
}

function typeWriterByWord(element, text, isThinkingBox) {
   if (typeof isThinkingBox === 'undefined') isThinkingBox = false;
   
   const words = text.split(' ');
   let wordIndex = 0;
   
   const copyButton = isThinkingBox ? null : element.querySelector('.copy-button');
   element.innerHTML = '';
   if (copyButton && !isThinkingBox) {
       element.appendChild(copyButton);
   }

   // Set isTyping ‡πÄ‡∏õ‡πá‡∏ô true ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏û‡∏¥‡∏°‡∏û‡πå
   isTyping = true;
   updateSendButton();

   function addNextWord() {
       if (wordIndex < words.length) {
           const currentText = words.slice(0, wordIndex + 1).join(' ');
           
           if (isThinkingBox) {
               element.textContent = currentText;
           } else {
               const withMarkdown = parseMarkdown(currentText);
               const textContainer = document.createElement('span');
               textContainer.innerHTML = convertLinksToClickable(withMarkdown);
               
               element.innerHTML = '';
               element.appendChild(textContainer);
               if (copyButton) {
                   element.appendChild(copyButton);
               }
           }
           
           wordIndex++;
           scrollToBottom();
           setTimeout(addNextWord, 150);
       } else {
           // ‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß
           isTyping = false;
           updateSendButton();
           scrollToBottom();
           
           if (!isThinkingBox) {
               const messageDiv = element.closest('.message');
               if (messageDiv) {
                   messageDiv.classList.add('typing-finished');
               }
           }
       }
   }

   addNextWord();
}

function stopTyping() {
   if (isTyping && currentTypingElement && currentTypingText) {
       isTyping = false;
       const copyButton = currentTypingElement.querySelector('.copy-button');
       const withMarkdown = parseMarkdown(currentTypingText);
       const textContainer = document.createElement('span');
       textContainer.innerHTML = convertLinksToClickable(withMarkdown);
       
       currentTypingElement.innerHTML = '';
       currentTypingElement.appendChild(textContainer);
       if (copyButton) {
           currentTypingElement.appendChild(copyButton);
       }
       
       updateSendButton();
       scrollToBottom();
       
       const messageDiv = currentTypingElement.closest('.message');
       if (messageDiv) {
           messageDiv.classList.add('typing-finished');
       }
   }
}

function updateSendButton() {
   const sendButton = document.getElementById('sendButton');
   if (isTyping) {
       sendButton.classList.add('spinning');
   } else {
       sendButton.classList.remove('spinning');
   }
}

function scrollToBottom() {
   const messages = document.getElementById('messages');
   messages.scrollTo({
       top: messages.scrollHeight,
       behavior: 'smooth'
   });
}

function sendQuickAction(command) {
   const input = document.getElementById('messageInput');
   input.value = command;
   sendMessage();
}

function sendMessage() {
   if (isTyping) {
       stopTyping();
       return;
   }

   const input = document.getElementById('messageInput');
   const sendButton = document.getElementById('sendButton');
   const question = input.value.trim();
   if (!question) return;

   if (!currentPreset) {
       alert('‡πÇ‡∏õ‡∏£‡∏î‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÇ‡∏´‡∏•‡∏î Presets ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
       return;
   }

   input.disabled = true;
   sendButton.disabled = true;
   isTyping = true;
   updateSendButton();
   addMessage(question, 'user', false);
   input.value = '';
   input.style.height = 'auto';
   showTypingIndicator();

   google.script.run
       .withSuccessHandler(answer => {
           hideTypingIndicator();
           input.disabled = false;
           sendButton.disabled = false;
           
           if (thinkingMode && currentMode === 'action') {
               try {
                   const parsedAnswer = JSON.parse(answer);
                   if (parsedAnswer.thinking && parsedAnswer.answer) {
                       // ‡πÄ‡∏õ‡∏¥‡∏î Thinking Box ‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏¥‡∏°‡∏û‡πå
                       addThinkingBox(parsedAnswer.thinking);
                       
                       // ‡∏£‡∏≠‡πÉ‡∏´‡πâ Thinking ‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡πà‡∏≠‡∏ô‡πÅ‡∏™‡∏î‡∏á Answer
                       const checkThinkingDone = setInterval(() => {
                           if (!isTyping) {
                               clearInterval(checkThinkingDone);
                               // Thinking ‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏û‡∏¥‡∏°‡∏û‡πå Answer
                               isTyping = true;
                               updateSendButton();
                               addMessage(parsedAnswer.answer, 'bot', true);
                           }
                       }, 100);
                       
                       input.focus();
                       return;
                   }
               } catch (e) {
                   console.log('Not JSON response, treating as normal');
               }
           }
           
           // ‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà Thinking Mode ‡∏´‡∏£‡∏∑‡∏≠ Parse ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
           isTyping = false;
           updateSendButton();
           input.focus();
           
           if (currentMode === 'array' && Array.isArray(answer)) {
               addMessage(answer[0][0], 'bot', true);
           } else {
               addMessage(answer, 'bot', true);
           }
       })
       .withFailureHandler(error => {
           hideTypingIndicator();
           input.disabled = false;
           sendButton.disabled = false;
           isTyping = false;
           updateSendButton();
           input.focus();
           addMessage('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.toString(), 'bot', true);
       })
       .processRealUniverseAI(question, currentPreset, currentTemperature, currentMode, turboMode, thinkingMode);
}

function showTypingIndicator() {
   const messages = document.getElementById('messages');
   const typingDiv = document.createElement('div');
   typingDiv.className = 'message bot';
   typingDiv.id = 'typing-indicator';

   const indicator = document.createElement('div');
   indicator.className = 'typing-indicator';
   indicator.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect width="10" height="10" x="1" y="1" fill="#8360c3" rx="1"><animate id="svgSpinnersBlocksShuffle30" fill="freeze" attributeName="x" begin="0;svgSpinnersBlocksShuffle3b.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle31" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle38.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle32" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle39.end" dur="0.21s" values="13;1"/><animate id="svgSpinnersBlocksShuffle33" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle3a.end" dur="0.21s" values="13;1"/></rect><rect width="10" height="10" x="1" y="13" fill="#8360c3" rx="1"><animate id="svgSpinnersBlocksShuffle34" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle30.end" dur="0.21s" values="13;1"/><animate id="svgSpinnersBlocksShuffle35" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle31.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle36" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle32.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle37" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle33.end" dur="0.21s" values="13;1"/></rect><rect width="10" height="10" x="13" y="13" fill="#8360c3" rx="1"><animate id="svgSpinnersBlocksShuffle38" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle34.end" dur="0.21s" values="13;1"/><animate id="svgSpinnersBlocksShuffle39" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle35.end" dur="0.21s" values="13;1"/><animate id="svgSpinnersBlocksShuffle3a" fill="freeze" attributeName="x" begin="svgSpinnersBlocksShuffle36.end" dur="0.21s" values="1;13"/><animate id="svgSpinnersBlocksShuffle3b" fill="freeze" attributeName="y" begin="svgSpinnersBlocksShuffle37.end" dur="0.21s" values="1;13"/></rect></svg>';

   typingDiv.appendChild(indicator);
   messages.appendChild(typingDiv);
   scrollToBottom();
}

function hideTypingIndicator() {
   const indicator = document.getElementById('typing-indicator');
   if (indicator) indicator.remove();
}

function toggleDisplayMode() {
   try {
       google.script.run
           .withSuccessHandler(() => {
           })
           .withFailureHandler(error => {
               console.error('Error toggling display mode:', error);
           })
           .toggleDisplayMode();
   } catch (e) {
       console.error('Error calling toggle function:', e);
   }
}

function initializeDisplayMode() {
   google.script.run
       .withSuccessHandler(mode => {
           const container = document.getElementById('main-container');
           const button = document.getElementById('mode-switch-button');
           
           if (mode === 'sidebar') {
               container.classList.add('sidebar-mode');
               button.innerHTML = '‚ñ¢‚ñ£';
           } else {
               container.classList.remove('sidebar-mode');
               button.innerHTML = '‚ñ¢‚ñ£';
           }
       })
       .withFailureHandler(() => {
           const container = document.getElementById('main-container');
           const button = document.getElementById('mode-switch-button');
           container.classList.remove('sidebar-mode');
           button.innerHTML = '‚ñ¢‚ñ£';
       })
       .getCurrentDisplayMode();
}

document.addEventListener('click', function(event) {
   const popup = document.getElementById('settingsPopup');
   const trigger = document.querySelector('.hamburger-btn');
   
   if (!popup.contains(event.target) && !trigger.contains(event.target)) {
       popup.classList.remove('show');
   }
});

const messageInput = document.getElementById('messageInput');
messageInput.addEventListener('input', function() {
   this.style.height = 'auto';
   this.style.height = this.scrollHeight + 'px';
});

messageInput.addEventListener('keypress', function(e) {
   if (e.key === 'Enter' && e.ctrlKey) {
       e.preventDefault();
       sendMessage();
   } else if (e.key === 'Enter' && !e.shiftKey) {
       e.preventDefault();
   }
});

window.onload = function() {
   setTimeout(() => {
       messageInput.focus();
   }, 100);
   
   loadDynamicPresets();
   updateMode();
   setInterval(updateSelectedCell, 1000);
   initializeDisplayMode();
};
</script>
</body>
</html>`;
}
